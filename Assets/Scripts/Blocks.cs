/*
 * Blocks.cs
 * RVO2 Library C#
 *
 * Copyright 2008 University of North Carolina at Chapel Hill
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Please send all bug reports to <geom@cs.unc.edu>.
 *
 * The authors may be contacted via:
 *
 * Jur van den Berg, Stephen J. Guy, Jamie Snape, Ming C. Lin, Dinesh Manocha
 * Dept. of Computer Science
 * 201 S. Columbia St.
 * Frederick P. Brooks, Jr. Computer Science Bldg.
 * Chapel Hill, N.C. 27599-3175
 * United States of America
 *
 * <http://gamma.cs.unc.edu/RVO2/>
 */

/*
 * Example file showing a demo with 100 agents split in four groups initially
 * positioned in four corners of the environment. Each agent attempts to move to
 * other side of the environment through a narrow passage generated by four
 * obstacles. There is no roadmap to guide the agents around the obstacles.
 */

#define RVO_SEED_RANDOM_NUMBER_GENERATOR

using System;
using System.Collections.Generic;
using UnityEngine;
using Random = System.Random;

namespace RVO
{
    class Blocks : MonoBehaviour
    {
        /* Store the gameObjects of the agents */
        private IList<GameObject> agentObjs = new List<GameObject>();

        public GameObject agentNode;

        public GameObject obstacleNode;

        public GameObject agentPrefab;

        public float moveSpeed = 2.0f;

        /* Store the goals of the agents. */
        IList<Vector2> goals;

        private IList<bool> arrived;

        /** Random number generator. */
        Random random;

        Blocks()
        {
            goals = new List<Vector2>();
            arrived = new List<bool>();

            #if RVO_SEED_RANDOM_NUMBER_GENERATOR
            random = new Random();
            #else
            random = new Random(0);
            #endif
        }
        
        // Start is called before the first frame update
        void Start()
        {
            // Blocks blocks = new Blocks();
            /* Set up the scenario. */
            setupScenario();

            if (agentNode == null)
                agentNode = GameObject.Find("Agents");

            if (obstacleNode == null)
                obstacleNode = GameObject.Find("Obstacles");
        }

        // Update is called once per frame
        void Update()
        {
        
            /* Perform (and manipulate) the simulation. */
            if (!reachedGoal())
            {
                // 输出当前位置
                updateVisualization();
                
                // 设定 pref 速度
                setPreferredVelocities();
                
                // 执行更新
                Simulator.Instance.doStep();
            }
        }
        
        void setupScenario()
        {
            /* Specify the global time step of the simulation. */
            Simulator.Instance.setTimeStep(0.25f);

            /*
             * Specify the default parameters for agents that are subsequently
             * added.
             */
            Simulator.Instance.setAgentDefaults(15.0f, 10, 5.0f, 5.0f, 
                2.0f, moveSpeed, new Vector2(0.0f, 0.0f));

            /*
             * Add agents, specifying their start position, and store their
             * goals on the opposite side of the environment.
             */
            for (int i = 0; i < 5; ++i)
            {
                for (int j = 0; j < 5; ++j)
                {
                    addAgent(new Vector2(55.0f + i * 10.0f, 55.0f + j * 10.0f));
                    goals.Add(new Vector2(-55.0f - j * 10.0f, -55.0f - i * 10.0f));

                    // addAgent(new Vector2(-55.0f - i * 10.0f, 55.0f + j * 10.0f));
                    // goals.Add(new Vector2(55.0f + i * 10.0f, -55.0f - j * 10.0f));
                    //
                    // addAgent(new Vector2(55.0f + i * 10.0f, -55.0f - j * 10.0f));
                    // goals.Add(new Vector2(-55.0f - i * 10.0f, 55.0f + j * 10.0f));
                    //
                    // addAgent(new Vector2(-55.0f - i * 10.0f, -55.0f - j * 10.0f));
                    // goals.Add(new Vector2(55.0f + i * 10.0f, 55.0f + j * 10.0f));
                }
            }

            /*
             * Add (polygonal) obstacles, specifying their vertices in
             * counterclockwise order.
             */
            IList<Vector2> obstacle1 = new List<Vector2>();
            obstacle1.Add(new Vector2(-10.0f, 40.0f));
            obstacle1.Add(new Vector2(-40.0f, 40.0f));
            obstacle1.Add(new Vector2(-40.0f, 10.0f));
            obstacle1.Add(new Vector2(-10.0f, 10.0f));
            createObstacle(obstacle1);
            
            // IList<Vector2> obstacle2 = new List<Vector2>();
            // obstacle2.Add(new Vector2(10.0f, 40.0f));
            // obstacle2.Add(new Vector2(10.0f, 10.0f));
            // obstacle2.Add(new Vector2(40.0f, 10.0f));
            // obstacle2.Add(new Vector2(40.0f, 40.0f));
            // createObstacle(obstacle2);
            
            IList<Vector2> obstacle3 = new List<Vector2>();
            obstacle3.Add(new Vector2(10.0f, -40.0f));
            obstacle3.Add(new Vector2(40.0f, -40.0f));
            obstacle3.Add(new Vector2(40.0f, -10.0f));
            obstacle3.Add(new Vector2(10.0f, -10.0f));
            createObstacle(obstacle3);
            
            IList<Vector2> obstacle4 = new List<Vector2>();
            obstacle4.Add(new Vector2(-10.0f, -40.0f));
            obstacle4.Add(new Vector2(-10.0f, -10.0f));
            obstacle4.Add(new Vector2(-40.0f, -10.0f));
            obstacle4.Add(new Vector2(-40.0f, -40.0f));
            createObstacle(obstacle4);
            
            IList<Vector2> lineObstacle = new List<Vector2>();
            lineObstacle.Add(new Vector2(0.0f, 40.0f));
            lineObstacle.Add(new Vector2(0.0f, 20.0f));
            lineObstacle.Add(new Vector2(20.0f, 0.0f));
            lineObstacle.Add(new Vector2(40.0f, 0.0f));
            createObstacle(lineObstacle);
            
            /*
             * Process the obstacles so that they are accounted for in the
             * simulation.
             */
            Simulator.Instance.processObstacles();
        }

        private void addAgent(Vector2 agentPos)
        {
            Simulator.Instance.addAgent(agentPos);

            // 下面为创建 Agent GameObjects
            if (agentPrefab == null)
                return;

            GameObject newAgentObj = GameObject.Instantiate(agentPrefab, agentNode.transform, true);
            newAgentObj.transform.position = new Vector3(agentPos.x(), 0, agentPos.y());
            agentObjs.Add(newAgentObj);
            
            arrived.Add(false);
        }
        
        void createObstacle(IList<Vector2> obstacleNodes)
        {
            Simulator.Instance.addObstacle(obstacleNodes);
            
            GameObject obstacleObj = new GameObject("obstacle");
            obstacleObj.transform.parent = obstacleNode.transform;
            MeshFilter filter = obstacleObj.AddComponent<MeshFilter>();
            MeshRenderer meshRenderer = obstacleObj.AddComponent<MeshRenderer>();
            
            Mesh mesh = new Mesh();
            filter.mesh = mesh;
            
            Vector3[] vertices = new Vector3[]{
                new Vector3(obstacleNodes[0].x(), 5, obstacleNodes[0].y()),
                new Vector3(obstacleNodes[1].x(), 5, obstacleNodes[1].y()),
                new Vector3(obstacleNodes[2].x(), 5, obstacleNodes[2].y()),
                new Vector3(obstacleNodes[3].x(), 5, obstacleNodes[3].y()),
            };
            
            mesh.name = "ObstacleMesh";
            mesh.vertices = vertices;
            // 通过顶点为网格创建三角形
            int[] triangles = new int[2 * 3]{
                0, 3, 1, 3, 2, 1
            };
            mesh.triangles = triangles;
            meshRenderer.material.color = Color.white;
        }
        
        void updateVisualization()
        {
            for (int i = 0; i < Simulator.Instance.getNumAgents(); ++i)
            {
                Vector2 pos = Simulator.Instance.getAgentPosition(i);
                Vector2 velocity = Simulator.Instance.getAgentVelocity(i);
                
                GameObject agentObj = agentObjs[i];
                if (agentObj != null)
                {
                    agentObj.transform.position = new Vector3(pos.x(), 0, pos.y());
                    Vector3 rota = new Vector3(velocity.x(), 0, velocity.y());
                    
                    if (!isAgentReached(i) && rota != Vector3.zero)
                    {
                        agentObj.transform.rotation = Quaternion.LookRotation(rota);
                    }
                }
            }
        }

        void setPreferredVelocities()
        {
            /*
             * Set the preferred velocity to be a vector of unit magnitude (speed) in the direction of the goal.
             * 设置首选速度为目标方向的单位大小（速度）的矢量
             */
            for (int i = 0; i < Simulator.Instance.getNumAgents(); ++i)
            {
                Vector2 goalVector = goals[i] - Simulator.Instance.getAgentPosition(i);

                if (RVOMath.absSq(goalVector) > 1.0f)
                {
                    goalVector = RVOMath.normalize(goalVector);
                }

                Simulator.Instance.setAgentPrefVelocity(i, goalVector);

                /*
                 * Perturb a little to avoid deadlocks due to perfect symmetry.
                 * 扰动一下以避免因完全对称而产生的死锁
                 */
                float angle = (float)random.NextDouble() * 2.0f * (float)Math.PI;
                float dist = (float)random.NextDouble() * 0.0001f;

                Simulator.Instance.setAgentPrefVelocity(i, Simulator.Instance.getAgentPrefVelocity(i) +
                    dist * new Vector2((float)Math.Cos(angle), (float)Math.Sin(angle)));
            }
        }

        bool reachedGoal()
        {
            /* Check if all agents have reached their goals. */
            for (int i = 0; i < Simulator.Instance.getNumAgents(); ++i)
            {
                if (!isAgentReached(i))
                {
                    return false;
                }
            }

            return true;
        }

        bool isAgentReached(int agentIndex)
        {
            if (arrived[agentIndex])
                return true;

            if (RVOMath.absSq(Simulator.Instance.getAgentPosition(agentIndex) - goals[agentIndex]) <= 0.1f)
            {
                // 设定默认方向
                GameObject agentObj = agentObjs[agentIndex];
                agentObj.transform.rotation = Quaternion.identity;
                Vector2 pos = goals[agentIndex];
                agentObj.transform.position = new Vector3(pos.x(), 0, pos.y());
                
                arrived[agentIndex] = true;
                return true;
            }

            return false;
        }
    }
}
